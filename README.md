# Sudoku

Cloneはシャーロコピーで参照をコピーしますよね？なぜ元の配列が操作されないのですか？


ChatGPT:
いい質問です。
Clone() は確かに シャローコピー（shallow copy）なんですが、
**多次元配列の場合は「配列本体」まで新しく作られる」**ので、
結果として元の配列は操作されません。

 詳細解説
1. シャローコピーとは
シャローコピーは「中の要素まではコピーせず、参照をコピーする」方式です。
例えば object[] のように参照型の配列なら、Clone() しても中の参照は共有します。

2. じゃあなぜ int[,] では元の配列に影響しない？
int は値型（struct）なので、中の要素自体が実際の値を持っています。
さらに、int[,] の場合は Clone() すると「新しい配列領域」が作られ、
その新しい配列に 値型の要素 が丸ごとコピーされます。

つまり：

元の配列とコピー後の配列は別物（領域が別）

値型は参照じゃなく実体コピーなのでリンクしていない

だからコピー先を変更しても元には影響しない

図解
元の配列
cpp
コピーする
編集する
qGrid (int[,])
 ├─ [0,0] = 5
 ├─ [0,1] = 3
 ...
Clone() 後
go
コピーする
編集する
copy (int[,])
 ├─ [0,0] = 5  // 値そのものがコピーされている
 ├─ [0,1] = 3
 ...
この時点で qGrid と copy は全く別の配列オブジェクトです。
なので copy[0,0] = 9 としても qGrid の中身は変わりません。

 注意点
もし Clone() する対象が object[,] や List<int>[,] のような参照型の配列だったら、

配列本体は別物になる

でも中の参照先は共有している
ので、参照型の要素を変更すれば元の配列にも影響します。

つまり今回の場合は：

int[,] は値型

Clone() は配列本体を新規作成
なので、完全に独立したコピーになるというわけです。

========================================================================================
int solutions = CountSolutions((int[,])qGrid.Clone());の(int[,])qGrid.Clone()はArray.Copy()ではだめなんですか？

結論から言うと、Array.Copy()でもできます。
ただし Clone() と Array.Copy() では目的も動きも少し違うので、意図に合わせて使い分ける必要があります。

1. Clone() の動き
Clone() は配列の同じ型の新しい配列インスタンスを作り、全要素をコピーします。

2次元配列（int[,]）の場合も、完全に同じ形の別配列ができます。
戻り値の型は object なので、(int[,]) のキャストが必要です。
内部では 要素のシャローコピーですが、int は値型なので実質ディープコピーと同じ。

// clone を変更しても qGrid は変わらない
int[,] clone = (int[,])qGrid.Clone();

2. Array.Copy() の動き
既存の配列に対して 要素をコピーするだけで、新しい配列は作りません。
Array.Copy() を使う場合、コピー先の配列を事前に用意する必要があります。

int[,] copy = new int[qGrid.GetLength(0), qGrid.GetLength(1)];
Array.Copy(qGrid, copy, qGrid.Length);

この書き方なら Clone() とほぼ同じ結果が得られます（新しい配列に全要素コピー）。

3. 違いのまとめ
項目					Clone()								Array.Copy()
新しい配列を作るか		作る（戻り値）							作らない（渡したコピー先を使う）
型の保持				元配列と同じ型							コピー先の型を自分で決める
パフォーマンス			ほぼ同等（内部的にもメモリブロックコピー）	ほぼ同等だがコピー先確保が必要
記述量					短い (int[,])qGrid.Clone()				長い（新しい配列の確保＋コピー）

4. このケースでの選択
CountSolutions に渡すときに毎回一時配列が必要なので、

可読性優先 → Clone() がシンプル
GC負荷・速度優先 → 一度だけ作業用配列を作って Array.Copy() や Buffer.BlockCopy() で使い回す

※Clone()による処理
※ジャグ配列に関しては別、ジャグ配列は参照型になる
※2次元配列は値型になる


====================================================================
2025/08/31
MainGameとMainGameLogicの役割が曖昧だった
その為、MainGameLogicはファサードパターンに修正して、各サブクラスの機能を持ちアクセスできるリストクラスに修正
MainGameUIをイベント登録および描画のみの処理にして、イベント発火のみに修正
MainGame側でMainGameLogicFacadeとMainGameUIの両方を受け渡し、数独の内容を完成させるクラスとしての役割に限定